/*******************************************************************************
################################################################################
#   Copyright (c) [2017-2019] [Radisys]                                        #
#                                                                              #
#   Licensed under the Apache License, Version 2.0 (the "License");            #
#   you may not use this file except in compliance with the License.           #
#   You may obtain a copy of the License at                                    #
#                                                                              #
#       http://www.apache.org/licenses/LICENSE-2.0                             #
#                                                                              #
#   Unless required by applicable law or agreed to in writing, software        #
#   distributed under the License is distributed on an "AS IS" BASIS,          #
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   #
#   See the License for the specific language governing permissions and        #
#   limitations under the License.                                             #
################################################################################
*******************************************************************************/

/************************************************************************
 
     Name:     sch_utils.c
  
     Type:     C source file
  
     Desc:     C source code for scheduler utilities
  
     File:     sch_utils.c
  
**********************************************************************/

/** @file sch_utils.c
@brief This file implements the schedulers util functions.
*/

/* header files */
#include "common_def.h"
#include "du_app_mac_inf.h"
#include "lrg.h"
#include "tfu.h"
#include "tfu.x"           /* TFU types */
#include "lrg.x"           /* layer management typedefs for MAC */
#include "mac_sch_interface.h"
#include "sch.h"
#include "sch_utils.h"
#include "math.h"

#ifdef NR_TDD
/* spec-38.213 Table 13-4 for SCS=30KHz */
/* Note: Picking Table 13-4 and not 13-6 since band supported is n78 and
 * corresponding minimum B/W is 10 MHz */
int8_t coresetIdxTable[MAX_CORESET_INDEX][4] = {
{   1,   24,   2,   0}, /* index 0  */
{   1,   24,   2,   1}, /* index 1  */
{   1,   24,   2,   2}, /* index 2  */
{   1,   24,   2,   3}, /* index 3  */
{   1,   24,   2,   4}, /* index 4  */
{   1,   24,   3,   0}, /* index 5  */
{   1,   24,   3,   1}, /* index 6  */
{   1,   24,   3,   2}, /* index 7  */
{   1,   24,   3,   3}, /* index 8  */
{   1,   24,   3,   4}, /* index 9  */
{   1,   48,   1,  12}, /* index 10 */
{   1,   48,   1,  14}, /* index 11 */
{   1,   48,   1,  16}, /* index 12 */
{   1,   48,   2,  12}, /* index 13 */
{   1,   48,   2,  14}, /* index 14 */
{   1,   48,   2,  16}, /* index 15 */
};
#else
/* spec-38.213 Table 13-1 for SCS=15KHz */
int8_t coresetIdxTable[MAX_CORESET_INDEX][4] = {
{   1,   24,   2,   0}, /* index 0  */
{   1,   24,   2,   2}, /* index 1  */
{   1,   24,   2,   4}, /* index 2  */
{   1,   24,   3,   0}, /* index 3  */
{   1,   24,   3,   2}, /* index 4  */
{   1,   24,   3,   4}, /* index 5  */
{   1,   48,   1,  12}, /* index 6  */
{   1,   48,   1,  16}, /* index 7  */
{   1,   48,   2,  12}, /* index 8  */
{   1,   48,   2,  16}, /* index 9  */
{   1,   48,   3,  12}, /* index 10 */
{   1,   48,   3,  16}, /* index 11 */
{   1,   96,   1,  38}, /* index 12 */
{   1,   96,   2,  38}, /* index 13 */
{   1,   96,   3,  38}, /* index 14 */
{   0,    0,   0,   0}, /* index 15 */
};
#endif

/* spec-38.213 Table 13-11 */
/* m value is scaled to 2, when using it in formula, divide by 2 */
/* firstSymbol will vary depends on i, hence not filled */
int8_t searchSpaceIdxTable[MAX_SEARCH_SPACE_INDEX][4] = {
{   0,    1,   2,   0}, /* index 0  */
{   0,    2,   1,   0}, /* index 1  */
{   2,    1,   2,   0}, /* index 2  */
{   2,    2,   1,   0}, /* index 3  */
{   5,    1,   2,   0}, /* index 4  */
{   5,    2,   1,   0}, /* index 5  */
{   7,    1,   2,   0}, /* index 6  */
{   7,    2,   1,   0}, /* index 7  */
{   0,    1,   4,   0}, /* index 8  */
{   5,    1,   4,   0}, /* index 9  */
{   0,    1,   2,   0}, /* index 10 */
{   0,    1,   2,   0}, /* index 11 */
{   2,    1,   2,   0}, /* index 12 */
{   2,    1,   2,   0}, /* index 13 */
{   5,    1,   2,   0}, /* index 14 */
{   5,    1,   2,   0}, /* index 15 */
};

/* RACH tables */

/* spec-38.211 Table 6.3.3.2-1 */
/* Lra, delFRa, delF, numRb, k' */
uint16_t numRbForPrachTable[MAX_RACH_NUM_RB_IDX][5] = {
{   839,  1.25,  15,   6,   7    }, /* index 0 */
{   839,  1.25,  30,   3,   1    }, /* index 1 */
{   839,  1.25,  60,   2,   133  }, /* index 2 */
{   839,  5,     15,   24,  12   }, /* index 3 */
{   839,  5,     30,   12,  10   }, /* index 4 */
{   839,  5,     60,   6,   7    }, /* index 5 */
{   139,  15,    15,   12,  2    }, /* index 6 */
{   139,  15,    30,   6,   2    }, /* index 7 */
{   139,  15,    60,   3,   2    }, /* index 8 */
{   139,  30,    15,   24,  2    }, /* index 9 */
{   139,  30,    30,   12,  2    }, /* index 10 */
{   139,  30,    60,   6,   2    }, /* index 11 */
{   139,  60,    60,   12,  2    }, /* index 12 */
{   139,  60,    120,  6,   2    }, /* index 13 */
{   139,  120,   60,   24,  2    }, /* index 14 */
{   139,  120,   120,  12,  2    }, /* index 15 */
};

#ifdef NR_TDD

/* prach config index Table 6.3.3.2-3 spec 38.211 
 * PRACH format given as follows:
 * 0 = 0
 * 1 = 1
 * 2 = 2
 * 3 = 3
 * 4 = A1
 * 5 = A2
 * 6 = A3
 * 7 = B1
 * 8 = B4
 * 9 = C0
 * 10 = C2
 * 11 = A1/B1
 * 12 = A2/B2
 * 13 = A3/B3 
 * Subframe num is represented considering 0-9 bits and
 * value 1 corresponds to the subframe that is valid 
 */

uint16_t prachCfgIdxTable[MAX_PRACH_CONFIG_IDX][8] = {
{ 0, 16,  1,  512,  0,  0,  0,  0 }, /* index 0   */
{ 0,  8,  1,  512,  0,  0,  0,  0 }, /* index 1   */
{ 0,  4,  1,  512,  0,  0,  0,  0 }, /* index 2   */
{ 0,  2,  0,  512,  0,  0,  0,  0 }, /* index 3   */
{ 0,  2,  1,  512,  0,  0,  0,  0 }, /* index 4   */
{ 0,  2,  0,   16,  0,  0,  0,  0 }, /* index 5   */
{ 0,  2,  1,   16,  0,  0,  0,  0 }, /* index 6   */
{ 0,  1,  0,  512,  0,  0,  0,  0 }, /* index 7   */
{ 0,  1,  0,  256,  0,  0,  0,  0 }, /* index 8   */
{ 0,  1,  0,  128,  0,  0,  0,  0 }, /* index 9   */
{ 0,  1,  0,   64,  0,  0,  0,  0 }, /* index 10  */
{ 0,  1,  0,   32,  0,  0,  0,  0 }, /* index 11  */
{ 0,  1,  0,   16,  0,  0,  0,  0 }, /* index 12  */
{ 0,  1,  0,    8,  0,  0,  0,  0 }, /* index 13  */
{ 0,  1,  0,    4,  0,  0,  0,  0 }, /* index 14  */
{ 0,  1,  0,   66,  0,  0,  0,  0 }, /* index 15  */
{ 0,  1,  0,   66,  7,  0,  0,  0 }, /* index 16  */
{ 0,  1,  0,  528,  0,  0,  0,  0 }, /* index 17  */
{ 0,  1,  0,  264,  0,  0,  0,  0 }, /* index 18  */
{ 0,  1,  0,  132,  0,  0,  0,  0 }, /* index 19  */
{ 0,  1,  0,  768,  0,  0,  0,  0 }, /* index 20  */
{ 0,  1,  0,  784,  0,  0,  0,  0 }, /* index 21  */
{ 0,  1,  0,  536,  0,  0,  0,  0 }, /* index 22  */
{ 0,  1,  0,  896,  0,  0,  0,  0 }, /* index 23  */
{ 0,  1,  0,  792,  0,  0,  0,  0 }, /* index 24  */
{ 0,  1,  0,  960,  0,  0,  0,  0 }, /* index 25  */
{ 0,  1,  0,  594,  0,  0,  0,  0 }, /* index 26  */
{ 0,  1,  0,  682,  0,  0,  0,  0 }, /* index 27  */
{ 1, 16,  1,  128,  0,  0,  0,  0 }, /* index 28  */
{ 1,  8,  1,  128,  0,  0,  0,  0 }, /* index 29  */
{ 1,  4,  1,  128,  0,  0,  0,  0 }, /* index 30  */
{ 1,  2,  0,  128,  0,  0,  0,  0 }, /* index 31  */
{ 1,  2,  1,  128,  0,  0,  0,  0 }, /* index 32  */
{ 1,  1,  0,  128,  0,  0,  0,  0 }, /* index 33  */
{ 2, 16,  1,   64,  0,  0,  0,  0 }, /* index 34  */
{ 2,  8,  1,   64,  0,  0,  0,  0 }, /* index 35  */
{ 2,  4,  1,   64,  0,  0,  0,  0 }, /* index 36  */
{ 2,  2,  0,   64,  7,  0,  0,  0 }, /* index 37  */
{ 2,  2,  1,   64,  7,  0,  0,  0 }, /* index 38  */
{ 2,  1,  0,   64,  7,  0,  0,  0 }, /* index 39  */
{ 3, 16,  1,  512,  0,  0,  0,  0 }, /* index 40  */
{ 3,  8,  1,  512,  0,  0,  0,  0 }, /* index 41  */
{ 3,  4,  1,  512,  0,  0,  0,  0 }, /* index 42  */
{ 3,  2,  0,  512,  0,  0,  0,  0 }, /* index 43  */
{ 3,  2,  1,  512,  0,  0,  0,  0 }, /* index 44  */
{ 3,  2,  0,   16,  0,  0,  0,  0 }, /* index 45  */
{ 3,  2,  1,   16,  0,  0,  0,  0 }, /* index 46  */
{ 3,  1,  0,  512,  0,  0,  0,  0 }, /* index 47  */
{ 3,  1,  0,  256,  0,  0,  0,  0 }, /* index 48  */
{ 3,  1,  0,  128,  0,  0,  0,  0 }, /* index 49  */
{ 3,  1,  0,   64,  0,  0,  0,  0 }, /* index 50  */
{ 3,  1,  0,   32,  0,  0,  0,  0 }, /* index 51  */
{ 3,  1,  0,   16,  0,  0,  0,  0 }, /* index 52  */
{ 3,  1,  0,    8,  0,  0,  0,  0 }, /* index 53  */
{ 3,  1,  0,    4,  0,  0,  0,  0 }, /* index 54  */
{ 3,  1,  0,   66,  0,  0,  0,  0 }, /* index 55  */
{ 3,  1,  0,   66,  7,  0,  0,  0 }, /* index 56  */
{ 3,  1,  0,  528,  0,  0,  0,  0 }, /* index 57  */
{ 3,  1,  0,  264,  0,  0,  0,  0 }, /* index 58  */
{ 3,  1,  0,  132,  0,  0,  0,  0 }, /* index 59  */
{ 3,  1,  0,  768,  0,  0,  0,  0 }, /* index 60  */
{ 3,  1,  0,  784,  0,  0,  0,  0 }, /* index 61  */
{ 3,  1,  0,  536,  0,  0,  0,  0 }, /* index 62  */
{ 3,  1,  0,  896,  0,  0,  0,  0 }, /* index 63  */
{ 3,  1,  0,  792,  0,  0,  0,  0 }, /* index 64  */
{ 3,  1,  0,  594,  0,  0,  0,  0 }, /* index 65  */
{ 3,  1,  0,  682,  0,  0,  0,  0 }, /* index 66  */
{ 4, 16,  1,  512,  0,  2,  6,  2 }, /* index 67  */
{ 4,  8,  1,  512,  0,  2,  6,  2 }, /* index 68  */
{ 4,  4,  1,  512,  0,  1,  6,  2 }, /* index 69  */
{ 4,  2,  1,  512,  0,  1,  6,  2 }, /* index 70  */
{ 4,  2,  1,  528,  7,  1,  3,  2 }, /* index 71  */
{ 4,  2,  1,  640,  7,  1,  3,  2 }, /* index 72  */
{ 4,  2,  1,  640,  0,  1,  6,  2 }, /* index 73  */
{ 4,  2,  1,  768,  0,  2,  6,  2 }, /* index 74  */
{ 4,  2,  1,  528,  0,  2,  6,  2 }, /* index 75  */
{ 4,  2,  1,  924,  0,  1,  6,  2 }, /* index 76  */
{ 4,  1,  0,  512,  0,  2,  6,  2 }, /* index 77  */
{ 4,  1,  0,  512,  7,  1,  3,  2 }, /* index 78  */
{ 4,  1,  0,  512,  0,  1,  6,  2 }, /* index 79  */
{ 4,  1,  0,  768,  0,  2,  6,  2 }, /* index 80  */
{ 4,  1,  0,  528,  0,  1,  6,  2 }, /* index 81  */
{ 4,  1,  0,  640,  7,  1,  3,  2 }, /* index 82  */
{ 4,  1,  0,  792,  0,  1,  6,  2 }, /* index 83  */
{ 4,  1,  0,  792,  0,  2,  6,  2 }, /* index 84  */
{ 4,  1,  0,  682,  0,  1,  6,  2 }, /* index 85  */
{ 4,  1,  0, 1023,  7,  1,  3,  2 }, /* index 86  */
{ 5, 16,  1,  512,  0,  2,  3,  4 }, /* index 87  */
{ 5,  8,  1,  512,  0,  2,  3,  4 }, /* index 88  */
{ 5,  4,  1,  512,  0,  1,  3,  4 }, /* index 89  */
{ 5,  2,  1,  640,  0,  1,  3,  4 }, /* index 90  */
{ 5,  2,  1,  768,  0,  2,  3,  4 }, /* index 91  */
{ 5,  2,  1,  640,  9,  1,  1,  4 }, /* index 92  */
{ 5,  2,  1,  528,  9,  1,  1,  4 }, /* index 93  */
{ 5,  2,  1,  528,  0,  2,  3,  4 }, /* index 94  */
{ 5,  2,  1,  924,  0,  1,  3,  4 }, /* index 95  */
{ 5,  1,  0,    4,  0,  1,  3,  4 }, /* index 96  */
{ 5,  1,  0,  128,  0,  1,  3,  4 }, /* index 97  */
{ 5,  2,  1,  512,  0,  1,  3,  4 }, /* index 98  */
{ 5,  1,  0,  512,  0,  2,  3,  4 }, /* index 99  */
{ 5,  1,  0,  512,  9,  1,  1,  4 }, /* index 100  */
{ 5,  1,  0,  512,  0,  1,  3,  4 }, /* index 101  */
{ 5,  1,  0,  132,  0,  1,  3,  4 }, /* index 102  */
{ 5,  1,  0,  768,  0,  2,  3,  4 }, /* index 103  */
{ 5,  1,  0,  528,  0,  1,  3,  4 }, /* index 104  */
{ 5,  1,  0,  640,  9,  1,  1,  4 }, /* index 105  */
{ 5,  1,  0,  792,  0,  1,  3,  4 }, /* index 106  */
{ 5,  1,  0,  792,  0,  2,  3,  4 }, /* index 107  */
{ 5,  1,  0,  682,  0,  1,  3,  4 }, /* index 108  */
{ 5,  1,  0, 1023,  9,  1,  1,  4 }, /* index 109  */
{ 6, 16,  1,  512,  0,  2,  2,  6 }, /* index 110  */
{ 6,  8,  1,  512,  0,  2,  2,  6 }, /* index 111  */
{ 6,  4,  1,  512,  0,  1,  2,  6 }, /* index 112  */
{ 6,  2,  1,  528,  7,  1,  1,  6 }, /* index 113  */
{ 6,  2,  1,  640,  7,  1,  1,  6 }, /* index 114  */
{ 6,  2,  1,  640,  0,  1,  2,  6 }, /* index 115  */
{ 6,  2,  1,  528,  0,  2,  2,  6 }, /* index 116  */
{ 6,  2,  1,  768,  0,  2,  2,  6 }, /* index 117  */
{ 6,  2,  1,  924,  0,  1,  2,  6 }, /* index 118  */
{ 6,  1,  0,    4,  0,  1,  2,  6 }, /* index 119  */
{ 6,  1,  0,  128,  0,  1,  2,  6 }, /* index 120  */
{ 6,  2,  1,  512,  0,  1,  2,  6 }, /* index 121  */
{ 6,  1,  0,  512,  0,  2,  2,  6 }, /* index 122  */
{ 6,  1,  0,  512,  7,  1,  1,  6 }, /* index 123  */
{ 6,  1,  0,  512,  0,  1,  2,  6 }, /* index 124  */
{ 6,  1,  0,  132,  0,  1,  2,  6 }, /* index 125  */
{ 6,  1,  0,  768,  0,  2,  2,  6 }, /* index 126  */
{ 6,  1,  0,  528,  0,  1,  2,  6 }, /* index 127  */
{ 6,  1,  0,  640,  7,  1,  1,  6 }, /* index 128  */
{ 6,  1,  0,  792,  0,  1,  2,  6 }, /* index 129  */
{ 6,  1,  0,  792,  0,  2,  2,  6 }, /* index 130  */
{ 6,  1,  0,  682,  0,  1,  2,  6 }, /* index 131  */
{ 6,  1,  0, 1023,  7,  1,  1,  6 }, /* index 132  */
{ 7,  4,  1,  512,  2,  1,  6,  2 }, /* index 133  */
{ 7,  2,  1,  512,  2,  1,  6,  2 }, /* index 134  */
{ 7,  2,  1,  640,  2,  1,  6,  2 }, /* index 135  */
{ 7,  2,  1,  528,  8,  1,  3,  2 }, /* index 136  */
{ 7,  2,  1,  528,  2,  2,  6,  2 }, /* index 137  */
{ 7,  1,  0,  512,  2,  2,  6,  2 }, /* index 138  */
{ 7,  1,  0,  512,  8,  1,  3,  2 }, /* index 139  */
{ 7,  1,  0,  512,  2,  1,  6,  2 }, /* index 140  */
{ 7,  1,  0,  768,  2,  2,  6,  2 }, /* index 141  */
{ 7,  1,  0,  528,  2,  1,  6,  2 }, /* index 142  */
{ 7,  1,  0,  640,  8,  1,  3,  2 }, /* index 143  */
{ 7,  1,  0,  682,  2,  1,  6,  2 }, /* index 144  */
{ 8, 16,  1,  512,  0,  2,  1, 12 }, /* index 145  */
{ 8,  8,  1,  512,  0,  2,  1, 12 }, /* index 146  */
{ 8,  4,  1,  512,  2,  1,  1, 12 }, /* index 147  */
{ 8,  2,  1,  512,  0,  1,  1, 12 }, /* index 148  */
{ 8,  2,  1,  512,  2,  1,  1, 12 }, /* index 149  */
{ 8,  2,  1,  640,  2,  1,  1, 12 }, /* index 150  */
{ 8,  2,  1,  528,  2,  1,  1, 12 }, /* index 151  */
{ 8,  2,  1,  528,  0,  2,  1, 12 }, /* index 152  */
{ 8,  2,  1,  768,  0,  2,  1, 12 }, /* index 153  */
{ 8,  2,  1,  924,  0,  1,  1, 12 }, /* index 154  */
{ 8,  1,  0,    2,  0,  1,  1, 12 }, /* index 155  */
{ 8,  1,  0,    4,  0,  1,  1, 12 }, /* index 156  */
{ 8,  1,  0,   16,  0,  1,  1, 12 }, /* index 157  */
{ 8,  1,  0,  128,  0,  1,  1, 12 }, /* index 158  */
{ 8,  1,  0,  512,  0,  1,  1, 12 }, /* index 159  */
{ 8,  1,  0,  512,  2,  1,  1, 12 }, /* index 160  */
{ 8,  1,  0,  512,  0,  2,  1, 12 }, /* index 161  */
{ 8,  1,  0,  528,  2,  1,  1, 12 }, /* index 162  */
{ 8,  1,  0,  640,  2,  1,  1, 12 }, /* index 163  */
{ 8,  1,  0,  768,  0,  2,  1, 12 }, /* index 164  */
{ 8,  1,  0,  792,  2,  1,  1, 12 }, /* index 165  */
{ 8,  1,  0,  682,  2,  1,  1, 12 }, /* index 166  */
{ 8,  1,  0, 1023,  0,  2,  1, 12 }, /* index 167  */
{ 8,  1,  0, 1023,  2,  1,  1, 12 }, /* index 168  */
{ 9, 16,  1,  512,  2,  2,  6,  2 }, /* index 169  */
{ 9,  8,  1,  512,  2,  2,  6,  2 }, /* index 170  */
{ 9,  4,  1,  512,  2,  1,  6,  2 }, /* index 171  */
{ 9,  2,  1,  512,  2,  1,  6,  2 }, /* index 172  */
{ 9,  2,  1,  768,  2,  2,  6,  2 }, /* index 173  */
{ 9,  2,  1,  640,  2,  1,  6,  2 }, /* index 174  */
{ 9,  2,  1,  640,  8,  1,  3,  2 }, /* index 175  */
{ 9,  2,  1,  528,  8,  1,  3,  2 }, /* index 176  */
{ 9,  2,  1,  528,  2,  2,  6,  2 }, /* index 177  */
{ 9,  2,  1,  924,  2,  1,  6,  2 }, /* index 178  */
{ 9,  1,  0,  512,  2,  2,  6,  2 }, /* index 179  */
{ 9,  1,  0,  512,  8,  1,  3,  2 }, /* index 180  */
{ 9,  1,  0,  512,  2,  1,  6,  2 }, /* index 181  */
{ 9,  1,  0,  768,  2,  2,  6,  2 }, /* index 182  */
{ 9,  1,  0,  528,  2,  1,  6,  2 }, /* index 183  */
{ 9,  1,  0,  640,  8,  1,  3,  2 }, /* index 184  */
{ 9,  1,  0,  792,  2,  1,  6,  2 }, /* index 185  */
{ 9,  1,  0,  792,  2,  2,  6,  2 }, /* index 186  */
{ 9,  1,  0,  682,  2,  1,  6,  2 }, /* index 187  */
{ 9,  1,  0, 1023,  8,  1,  3,  2 }, /* index 188  */
{10, 16,  1,  512,  2,  2,  2,  6 }, /* index 189  */
{10,  8,  1,  512,  2,  2,  2,  6 }, /* index 190  */
{10,  4,  1,  512,  2,  1,  2,  6 }, /* index 191  */
{10,  2,  1,  512,  2,  1,  2,  6 }, /* index 192  */
{10,  2,  1,  768,  2,  2,  2,  6 }, /* index 193  */
{10,  2,  1,  640,  2,  1,  2,  6 }, /* index 194  */
{10,  2,  1,  640,  8,  1,  1,  6 }, /* index 195  */
{10,  2,  1,  528,  8,  1,  1,  6 }, /* index 196  */
{10,  2,  1,  528,  2,  2,  2,  6 }, /* index 197  */
{10,  2,  1,  924,  2,  1,  2,  6 }, /* index 198  */
{10,  8,  1,  512,  8,  2,  1,  6 }, /* index 199  */
{10,  4,  1,  512,  8,  1,  1,  6 }, /* index 200  */
{10,  1,  0,  512,  2,  2,  2,  6 }, /* index 201  */
{10,  1,  0,  512,  8,  1,  1,  6 }, /* index 202  */
{10,  1,  0,  512,  2,  1,  2,  6 }, /* index 203  */
{10,  1,  0,  768,  2,  2,  2,  6 }, /* index 204  */
{10,  1,  0,  528,  2,  1,  2,  6 }, /* index 205  */
{10,  1,  0,  640,  8,  1,  1,  6 }, /* index 206  */
{10,  1,  0,  792,  2,  1,  2,  6 }, /* index 207  */
{10,  1,  0,  792,  2,  2,  2,  6 }, /* index 208  */
{10,  1,  0,  682,  2,  1,  2,  6 }, /* index 209  */
{10,  1,  0, 1023,  8,  1,  1,  6 }, /* index 210  */
{11,  2,  1,  512,  2,  1,  6,  2 }, /* index 211  */
{11,  2,  1,  528,  8,  1,  3,  2 }, /* index 212  */
{11,  2,  1,  640,  8,  1,  3,  2 }, /* index 213  */
{11,  2,  1,  640,  2,  1,  6,  2 }, /* index 214  */
{11,  2,  1,  528,  2,  2,  6,  2 }, /* index 215  */
{11,  2,  1,  768,  2,  2,  6,  2 }, /* index 216  */
{11,  1,  0,  512,  2,  2,  6,  2 }, /* index 217  */
{11,  1,  0,  512,  8,  1,  3,  2 }, /* index 218  */
{11,  1,  0,  512,  2,  1,  6,  2 }, /* index 219  */
{11,  1,  0,  768,  2,  2,  6,  2 }, /* index 220  */
{11,  1,  0,  528,  2,  1,  6,  2 }, /* index 221  */
{11,  1,  0,  640,  8,  1,  3,  2 }, /* index 222  */
{11,  1,  0,  792,  2,  2,  6,  2 }, /* index 223  */
{11,  1,  0,  682,  2,  1,  6,  2 }, /* index 224  */
{11,  1,  0, 1023,  8,  1,  3,  2 }, /* index 225  */
{12,  2,  1,  512,  0,  1,  3,  4 }, /* index 226  */
{12,  2,  1,  528,  6,  1,  2,  4 }, /* index 227  */
{12,  2,  1,  640,  6,  1,  2,  4 }, /* index 228  */
{12,  2,  1,  528,  0,  2,  3,  4 }, /* index 229  */
{12,  2,  1,  768,  0,  2,  3,  4 }, /* index 230  */
{12,  1,  0,  512,  0,  2,  3,  4 }, /* index 231  */
{12,  1,  0,  512,  6,  1,  2,  4 }, /* index 232  */
{12,  1,  0,  512,  0,  1,  3,  4 }, /* index 233  */
{12,  1,  0,  768,  0,  2,  3,  4 }, /* index 234  */
{12,  1,  0,  528,  0,  1,  3,  4 }, /* index 235  */
{12,  1,  0,  640,  6,  1,  2,  4 }, /* index 236  */
{12,  1,  0,  792,  0,  1,  3,  4 }, /* index 237  */
{12,  1,  0,  792,  0,  2,  3,  4 }, /* index 238  */
{12,  1,  0,  682,  0,  1,  3,  4 }, /* index 239  */
{12,  1,  0, 1023,  6,  1,  2,  4 }, /* index 240  */
{13,  2,  1,  512,  0,  1,  2,  6 }, /* index 241  */
{13,  2,  1,  528,  2,  1,  2,  6 }, /* index 242  */
{13,  2,  1,  640,  0,  1,  2,  6 }, /* index 243  */
{13,  2,  1,  640,  2,  1,  2,  6 }, /* index 244  */
{13,  2,  1,  528,  0,  2,  2,  6 }, /* index 245  */
{13,  2,  1,  768,  0,  2,  2,  6 }, /* index 246  */
{13,  1,  0,  512,  0,  2,  2,  6 }, /* index 247  */
{13,  1,  0,  512,  2,  1,  2,  6 }, /* index 248  */
{13,  1,  0,  512,  0,  1,  2,  6 }, /* index 249  */
{13,  1,  0,  768,  0,  2,  2,  6 }, /* index 250  */
{13,  1,  0,  528,  0,  1,  2,  6 }, /* index 251  */
{13,  1,  0,  640,  2,  1,  2,  6 }, /* index 252  */
{13,  1,  0,  792,  0,  2,  2,  6 }, /* index 253  */
{13,  1,  0,  682,  0,  1,  2,  6 }, /* index 254  */
{13,  1,  0, 1023,  2,  1,  2,  6 }  /* index 255  */
};

#else
/* prach config index Table 6.3.3.2-2 spec 38.211 
 * PRACH format given as follows:
 * 0 = 0
 * 1 = 1
 * 2 = 2
 * 3 = 3
 * 4 = A1
 * 5 = A2
 * 6 = A3
 * 7 = B1
 * 8 = B4
 * 9 = C0
 * 10 = C2
 * 11 = A1/B1
 * 12 = A2/B2
 * 13 = A3/B3 
 * Subframe num is represented considering 0-9 bits and
 * value 1 corresponds to the subframe that is valid 
 */

uint16_t prachCfgIdxTable[MAX_PRACH_CONFIG_IDX][8] = {
{ 0, 16,  1,    2,  0,  0,  0,  0 }, /* index 0   */
{ 0, 16,  1,   16,  0,  0,  0,  0 }, /* index 1   */
{ 0, 16,  1,  128,  0,  0,  0,  0 }, /* index 2   */
{ 0, 16,  1,  512,  0,  0,  0,  0 }, /* index 3   */
{ 0,  8,  1,    2,  0,  0,  0,  0 }, /* index 4   */
{ 0,  8,  1,   16,  0,  0,  0,  0 }, /* index 5   */
{ 0,  8,  1,  128,  0,  0,  0,  0 }, /* index 6   */
{ 0,  8,  1,  512,  0,  0,  0,  0 }, /* index 7   */
{ 0,  4,  1,    2,  0,  0,  0,  0 }, /* index 8   */
{ 0,  4,  1,   16,  0,  0,  0,  0 }, /* index 9   */
{ 0,  4,  1,  128,  0,  0,  0,  0 }, /* index 10  */
{ 0,  4,  1,  512,  0,  0,  0,  0 }, /* index 11  */
{ 0,  2,  1,    2,  0,  0,  0,  0 }, /* index 12  */
{ 0,  2,  1,   16,  0,  0,  0,  0 }, /* index 13  */
{ 0,  2,  1,  128,  0,  0,  0,  0 }, /* index 14  */
{ 0,  2,  1,  512,  0,  0,  0,  0 }, /* index 15  */
{ 0,  1,  0,    2,  0,  0,  0,  0 }, /* index 16  */
{ 0,  1,  0,   16,  0,  0,  0,  0 }, /* index 17  */
{ 0,  1,  0,  128,  0,  0,  0,  0 }, /* index 18  */
{ 0,  1,  0,   66,  0,  0,  0,  0 }, /* index 19  */
{ 0,  1,  0,  132,  0,  0,  0,  0 }, /* index 20  */
{ 0,  1,  0,  264,  0,  0,  0,  0 }, /* index 21  */
{ 0,  1,  0,  146,  0,  0,  0,  0 }, /* index 22  */
{ 0,  1,  0,  292,  0,  0,  0,  0 }, /* index 23  */
{ 0,  1,  0,  584,  0,  0,  0,  0 }, /* index 24  */
{ 0,  1,  0,  341,  0,  0,  0,  0 }, /* index 25  */
{ 0,  1,  0,  682,  0,  0,  0,  0 }, /* index 26  */
{ 0,  1,  0, 1023,  0,  0,  0,  0 }, /* index 27  */
{ 1, 16,  1,    2,  0,  0,  0,  0 }, /* index 28  */
{ 1, 16,  1,   16,  0,  0,  0,  0 }, /* index 29  */
{ 1, 16,  1,  128,  0,  0,  0,  0 }, /* index 30  */
{ 1, 16,  1,  512,  0,  0,  0,  0 }, /* index 31  */
{ 1,  8,  1,    2,  0,  0,  0,  0 }, /* index 32  */
{ 1,  8,  1,   16,  0,  0,  0,  0 }, /* index 33  */
{ 1,  8,  1,  128,  0,  0,  0,  0 }, /* index 34  */
{ 1,  8,  1,  512,  0,  0,  0,  0 }, /* index 35  */
{ 1,  4,  1,    2,  0,  0,  0,  0 }, /* index 36  */
{ 1,  4,  1,   16,  0,  0,  0,  0 }, /* index 37  */
{ 1,  4,  1,  128,  0,  0,  0,  0 }, /* index 38  */
{ 1,  4,  1,  512,  0,  0,  0,  0 }, /* index 39  */
{ 1,  2,  1,    2,  0,  0,  0,  0 }, /* index 40  */
{ 1,  2,  1,   16,  0,  0,  0,  0 }, /* index 41  */
{ 1,  2,  1,  128,  0,  0,  0,  0 }, /* index 42  */
{ 1,  2,  1,  512,  0,  0,  0,  0 }, /* index 43  */
{ 1,  1,  0,    2,  0,  0,  0,  0 }, /* index 44  */
{ 1,  1,  0,   16,  0,  0,  0,  0 }, /* index 45  */
{ 1,  1,  0,  128,  0,  0,  0,  0 }, /* index 46  */
{ 1,  1,  0,   64,  0,  0,  0,  0 }, /* index 47  */
{ 1,  1,  0,  132,  0,  0,  0,  0 }, /* index 48  */
{ 1,  1,  0,  264,  0,  0,  0,  0 }, /* index 49  */
{ 1,  1,  0,  146,  0,  0,  0,  0 }, /* index 50  */
{ 1,  1,  0,  292,  0,  0,  0,  0 }, /* index 51  */
{ 1,  1,  0,  584,  0,  0,  0,  0 }, /* index 52  */
{ 2, 16,  1,    2,  0,  0,  0,  0 }, /* index 53  */
{ 2,  8,  1,    2,  0,  0,  0,  0 }, /* index 54  */
{ 2,  4,  0,    2,  0,  0,  0,  0 }, /* index 55  */
{ 2,  2,  0,    2,  0,  0,  0,  0 }, /* index 56  */
{ 2,  2,  0,   32,  0,  0,  0,  0 }, /* index 57  */
{ 2,  1,  0,    2,  0,  0,  0,  0 }, /* index 58  */
{ 2,  1,  0,   32,  0,  0,  0,  0 }, /* index 59  */
{ 3, 16,  1,    2,  0,  0,  0,  0 }, /* index 60  */
{ 3, 16,  1,   16,  0,  0,  0,  0 }, /* index 61  */
{ 3, 16,  1,  128,  0,  0,  0,  0 }, /* index 62  */
{ 3, 16,  1,  512,  0,  0,  0,  0 }, /* index 63  */
{ 3,  8,  1,    2,  0,  0,  0,  0 }, /* index 64  */
{ 3,  8,  1,   16,  0,  0,  0,  0 }, /* index 65  */
{ 3,  8,  1,  128,  0,  0,  0,  0 }, /* index 66  */
{ 3,  4,  1,    2,  0,  0,  0,  0 }, /* index 67  */
{ 3,  4,  1,   16,  0,  0,  0,  0 }, /* index 68  */
{ 3,  4,  1,  128,  0,  0,  0,  0 }, /* index 69  */
{ 3,  4,  1,  512,  0,  0,  0,  0 }, /* index 70  */
{ 3,  2,  1,    2,  0,  0,  0,  0 }, /* index 71  */
{ 3,  2,  1,   16,  0,  0,  0,  0 }, /* index 72  */
{ 3,  2,  1,  128,  0,  0,  0,  0 }, /* index 73  */
{ 3,  2,  1,  512,  0,  0,  0,  0 }, /* index 74  */
{ 3,  1,  0,    2,  0,  0,  0,  0 }, /* index 75  */
{ 3,  1,  0,   16,  0,  0,  0,  0 }, /* index 76  */
{ 3,  1,  0,  128,  0,  0,  0,  0 }, /* index 77  */
{ 3,  1,  0,   66,  0,  0,  0,  0 }, /* index 78  */
{ 3,  1,  0,  132,  0,  0,  0,  0 }, /* index 79  */
{ 3,  1,  0,  264,  0,  0,  0,  0 }, /* index 80  */
{ 3,  1,  0,  146,  0,  0,  0,  0 }, /* index 81  */
{ 3,  1,  0,  292,  0,  0,  0,  0 }, /* index 82  */
{ 3,  1,  0,  584,  0,  0,  0,  0 }, /* index 83  */
{ 3,  1,  0,  341,  0,  0,  0,  0 }, /* index 84  */
{ 3,  1,  0,  682,  0,  0,  0,  0 }, /* index 85  */
{ 3,  1,  0, 1023,  0,  0,  0,  0 }, /* index 86  */
{ 4, 16,  0,  528,  0,  1,  6,  2 }, /* index 87  */
{ 4, 16,  1,   16,  0,  2,  6,  2 }, /* index 88  */
{ 4,  8,  0,  528,  0,  1,  6,  2 }, /* index 89  */
{ 4,  8,  1,   16,  0,  2,  6,  2 }, /* index 90  */
{ 4,  4,  0,  528,  0,  1,  6,  2 }, /* index 91  */
{ 4,  4,  1,  528,  0,  1,  6,  2 }, /* index 92  */
{ 4,  4,  0,   16,  0,  2,  6,  2 }, /* index 93  */
{ 4,  2,  0,  528,  0,  1,  6,  2 }, /* index 94  */
{ 4,  2,  0,    2,  0,  2,  6,  2 }, /* index 95  */
{ 4,  2,  0,   16,  0,  2,  6,  2 }, /* index 96  */
{ 4,  2,  0,  128,  0,  2,  6,  2 }, /* index 97  */
{ 4,  1,  0,   16,  0,  1,  6,  2 }, /* index 98  */
{ 4,  1,  0,   66,  0,  1,  6,  2 }, /* index 99  */
{ 4,  1,  0,  528,  0,  1,  6,  2 }, /* index 100  */
{ 4,  1,  0,    2,  0,  2,  6,  2 }, /* index 101  */
{ 4,  1,  0,  128,  0,  2,  6,  2 }, /* index 102  */
{ 4,  1,  0,  132,  0,  2,  6,  2 }, /* index 103  */
{ 4,  1,  0,  146,  0,  2,  6,  2 }, /* index 104  */
{ 4,  1,  0,  341,  0,  2,  6,  2 }, /* index 105  */
{ 4,  1,  0, 1023,  0,  2,  6,  2 }, /* index 106  */
{ 4,  1,  0,  682,  0,  2,  6,  2 }, /* index 107  */
{11,  2,  0,  528,  0,  1,  7,  2 }, /* index 108  */
{11,  2,  0,   16,  0,  2,  7,  2 }, /* index 109  */
{11,  1,  0,   16,  0,  1,  7,  2 }, /* index 110  */
{11,  1,  0,   66,  0,  1,  7,  2 }, /* index 111  */
{11,  1,  0,  528,  0,  1,  7,  2 }, /* index 112  */
{11,  1,  0,    2,  0,  2,  7,  2 }, /* index 113  */
{11,  1,  0,  128,  0,  2,  7,  2 }, /* index 114  */
{11,  1,  0,  146,  0,  2,  7,  2 }, /* index 115  */
{11,  1,  0,  341,  0,  2,  7,  2 }, /* index 116  */
{ 5, 16,  1,  580,  0,  1,  3,  4 }, /* index 117  */
{ 5, 16,  1,   16,  0,  2,  3,  4 }, /* index 118  */
{ 5,  8,  1,  580,  0,  1,  3,  4 }, /* index 119  */
{ 5,  8,  1,   16,  0,  2,  3,  4 }, /* index 120  */
{ 5,  4,  0,  580,  0,  1,  3,  4 }, /* index 121  */
{ 5,  4,  0,   16,  0,  2,  3,  4 }, /* index 122  */
{ 5,  2,  1,  580,  0,  1,  3,  4 }, /* index 123  */
{ 5,  2,  0,    2,  0,  2,  3,  4 }, /* index 124  */
{ 5,  2,  0,   16,  0,  2,  3,  4 }, /* index 125  */
{ 5,  2,  0,  128,  0,  2,  3,  4 }, /* index 126  */
{ 5,  1,  0,   16,  0,  1,  3,  4 }, /* index 127  */
{ 5,  1,  0,   66,  0,  1,  3,  4 }, /* index 128  */
{ 5,  1,  0,  528,  0,  1,  3,  4 }, /* index 129  */
{ 5,  1,  0,    2,  0,  2,  3,  4 }, /* index 130  */
{ 5,  1,  0,  128,  0,  2,  3,  4 }, /* index 131  */
{ 5,  1,  0,  132,  0,  2,  3,  4 }, /* index 132  */
{ 5,  1,  0,  146,  0,  2,  3,  4 }, /* index 133  */
{ 5,  1,  0,  341,  0,  2,  3,  4 }, /* index 134  */
{ 5,  1,  0, 1023,  0,  2,  3,  4 }, /* index 135  */
{ 5,  1,  0,  682,  0,  2,  3,  4 }, /* index 136  */
{12,  2,  1,  580,  0,  1,  3,  4 }, /* index 137  */
{12,  2,  0,   16,  0,  2,  3,  4 }, /* index 138  */
{12,  1,  0,   16,  0,  1,  3,  4 }, /* index 139  */
{12,  1,  0,   66,  0,  1,  3,  4 }, /* index 140  */
{12,  1,  0,  528,  0,  1,  3,  4 }, /* index 141  */
{12,  1,  0,    2,  0,  2,  3,  4 }, /* index 142  */
{12,  1,  0,  128,  0,  2,  3,  4 }, /* index 143  */
{12,  1,  0,  146,  0,  2,  3,  4 }, /* index 144  */
{12,  1,  0,  341,  0,  2,  3,  4 }, /* index 145  */
{12,  1,  0, 1023,  0,  2,  3,  4 }, /* index 146  */
{ 6, 16,  1,  528,  0,  1,  2,  6 }, /* index 147  */
{ 6, 16,  1,   16,  0,  2,  2,  6 }, /* index 148  */
{ 6,  8,  1,  528,  0,  1,  2,  6 }, /* index 149  */
{ 6,  8,  1,   16,  0,  2,  2,  6 }, /* index 150  */
{ 6,  4,  0,  528,  0,  1,  2,  6 }, /* index 151  */
{ 6,  4,  0,   16,  0,  2,  2,  6 }, /* index 152  */
{ 6,  2,  1,  580,  0,  2,  2,  6 }, /* index 153  */
{ 6,  2,  0,    2,  0,  2,  2,  6 }, /* index 154  */
{ 6,  2,  0,   16,  0,  2,  2,  6 }, /* index 155  */
{ 6,  2,  0,  128,  0,  2,  2,  6 }, /* index 156  */
{ 6,  1,  0,   16,  0,  1,  2,  6 }, /* index 157  */
{ 6,  1,  0,   66,  0,  1,  2,  6 }, /* index 158  */
{ 6,  1,  0,  528,  0,  1,  2,  6 }, /* index 159  */
{ 6,  1,  0,    2,  0,  2,  2,  6 }, /* index 160  */
{ 6,  1,  0,  128,  0,  2,  2,  6 }, /* index 161  */
{ 6,  1,  0,  132,  0,  2,  2,  6 }, /* index 162  */
{ 6,  1,  0,  146,  0,  2,  2,  6 }, /* index 163  */
{ 6,  1,  0,  341,  0,  2,  2,  6 }, /* index 164  */
{ 6,  1,  0, 1023,  0,  2,  2,  6 }, /* index 165  */
{ 6,  1,  0,  682,  0,  2,  2,  6 }, /* index 166  */
{13,  2,  1,  580,  0,  2,  2,  6 }, /* index 167  */
{13,  2,  0,   16,  0,  2,  2,  6 }, /* index 168  */
{13,  1,  0,   16,  0,  1,  2,  6 }, /* index 169  */
{13,  1,  0,   66,  0,  1,  2,  6 }, /* index 170  */
{13,  1,  0,  528,  0,  1,  2,  6 }, /* index 171  */
{13,  1,  0,    2,  0,  2,  2,  6 }, /* index 172  */
{13,  1,  0,  128,  0,  2,  2,  6 }, /* index 173  */
{13,  1,  0,  146,  0,  2,  2,  6 }, /* index 174  */
{13,  1,  0,  341,  0,  2,  2,  6 }, /* index 175  */
{13,  1,  0, 1023,  0,  2,  2,  6 }, /* index 176  */
{ 7, 16,  0,  528,  0,  1,  7,  2 }, /* index 177  */
{ 7, 16,  1,   16,  0,  2,  7,  2 }, /* index 178  */
{ 7,  8,  0,  528,  0,  1,  7,  2 }, /* index 179  */
{ 7,  8,  1,   16,  0,  2,  7,  2 }, /* index 180  */
{ 7,  4,  0,  528,  0,  1,  7,  2 }, /* index 181  */
{ 7,  4,  1,  528,  0,  1,  7,  2 }, /* index 182  */
{ 7,  4,  0,   16,  0,  2,  7,  2 }, /* index 183  */
{ 7,  2,  0,  528,  0,  1,  7,  2 }, /* index 184  */
{ 7,  2,  0,    2,  0,  2,  7,  2 }, /* index 185  */
{ 7,  2,  0,   16,  0,  2,  7,  2 }, /* index 186  */
{ 7,  2,  0,  128,  0,  2,  7,  2 }, /* index 187  */
{ 7,  1,  0,   16,  0,  1,  7,  2 }, /* index 188  */
{ 7,  1,  0,   66,  0,  1,  7,  2 }, /* index 189  */
{ 7,  1,  0,  528,  0,  1,  7,  2 }, /* index 190  */
{ 7,  1,  0,    2,  0,  2,  7,  2 }, /* index 191  */
{ 7,  1,  0,  128,  0,  2,  7,  2 }, /* index 192  */
{ 7,  1,  0,  132,  0,  2,  7,  2 }, /* index 193  */
{ 7,  1,  0,  146,  0,  2,  7,  2 }, /* index 194  */
{ 7,  1,  0,  341,  0,  2,  7,  2 }, /* index 195  */
{ 7,  1,  0, 1023,  0,  2,  7,  2 }, /* index 196  */
{ 7,  1,  0,  682,  0,  2,  7,  2 }, /* index 197  */
{ 8, 16,  0,  528,  0,  2,  1, 12 }, /* index 198  */
{ 8, 16,  1,   16,  0,  2,  1, 12 }, /* index 199  */
{ 8,  8,  0,  528,  0,  2,  1, 12 }, /* index 200  */
{ 8,  8,  1,   16,  0,  2,  1, 12 }, /* index 201  */
{ 8,  4,  0,  528,  0,  2,  1, 12 }, /* index 202  */
{ 8,  4,  0,   16,  0,  2,  1, 12 }, /* index 203  */
{ 8,  4,  1,  528,  0,  2,  1, 12 }, /* index 204  */
{ 8,  2,  0,  528,  0,  2,  1, 12 }, /* index 205  */
{ 8,  2,  0,    2,  0,  2,  1, 12 }, /* index 206  */
{ 8,  2,  0,   16,  0,  2,  1, 12 }, /* index 207  */
{ 8,  2,  0,  128,  0,  2,  1, 12 }, /* index 208  */
{ 8,  1,  0,    2,  0,  2,  1, 12 }, /* index 209  */
{ 8,  1,  0,   16,  0,  2,  1, 12 }, /* index 210  */
{ 8,  1,  0,  128,  0,  2,  1, 12 }, /* index 211  */
{ 8,  1,  0,   66,  0,  2,  1, 12 }, /* index 212  */
{ 8,  1,  0,  132,  0,  2,  1, 12 }, /* index 213  */
{ 8,  1,  0,  528,  0,  2,  1, 12 }, /* index 214  */
{ 8,  1,  0,  146,  0,  2,  1, 12 }, /* index 215  */
{ 8,  1,  0,  341,  0,  2,  1, 12 }, /* index 216  */
{ 8,  1,  0, 1023,  0,  2,  1, 12 }, /* index 217  */
{ 8,  1,  0,  682,  0,  2,  1, 12 }, /* index 218  */
{ 9,  8,  1,   16,  0,  2,  7,  2 }, /* index 219  */
{ 9,  4,  1,  528,  0,  1,  7,  2 }, /* index 220  */
{ 9,  4,  0,   16,  0,  2,  7,  2 }, /* index 221  */
{ 9,  2,  0,  528,  0,  1,  7,  2 }, /* index 222  */
{ 9,  2,  0,    2,  0,  2,  7,  2 }, /* index 223  */
{ 9,  2,  0,   16,  0,  2,  7,  2 }, /* index 224  */
{ 9,  2,  0,  128,  0,  2,  7,  2 }, /* index 225  */
{ 9,  1,  0,   16,  0,  1,  7,  2 }, /* index 226  */
{ 9,  1,  0,   66,  0,  1,  7,  2 }, /* index 227  */
{ 9,  1,  0,  528,  0,  1,  7,  2 }, /* index 228  */
{ 9,  1,  0,    2,  0,  2,  7,  2 }, /* index 229  */
{ 9,  1,  0,  128,  0,  2,  7,  2 }, /* index 230  */
{ 9,  1,  0,  132,  0,  2,  7,  2 }, /* index 231  */
{ 9,  1,  0,  146,  0,  2,  7,  2 }, /* index 232  */
{ 9,  1,  0,  341,  0,  2,  7,  2 }, /* index 233  */
{ 9,  1,  0, 1023,  0,  2,  7,  2 }, /* index 234  */
{ 9,  1,  0,  682,  0,  2,  7,  2 }, /* index 235  */
{10, 16,  1,  528,  0,  1,  2,  6 }, /* index 236  */
{10, 16,  1,   16,  0,  2,  2,  6 }, /* index 237  */
{10,  8,  1,  528,  0,  1,  2,  6 }, /* index 238  */
{10,  8,  1,   16,  0,  2,  2,  6 }, /* index 239  */
{10,  4,  0,  528,  0,  1,  2,  6 }, /* index 240  */
{10,  4,  0,   16,  0,  2,  2,  6 }, /* index 241  */
{10,  2,  1,  580,  0,  2,  2,  6 }, /* index 242  */
{10,  2,  0,    2,  0,  2,  2,  6 }, /* index 243  */
{10,  2,  0,   16,  0,  2,  2,  6 }, /* index 244  */
{10,  2,  0,  128,  0,  2,  2,  6 }, /* index 245  */
{10,  1,  0,   16,  0,  1,  2,  6 }, /* index 246  */
{10,  1,  0,   66,  0,  1,  2,  6 }, /* index 247  */
{10,  1,  0,  528,  0,  1,  2,  6 }, /* index 248  */
{10,  1,  0,    2,  0,  2,  2,  6 }, /* index 249  */
{10,  1,  0,  128,  0,  2,  2,  6 }, /* index 250  */
{10,  1,  0,  132,  0,  2,  2,  6 }, /* index 251  */
{10,  1,  0,  146,  0,  2,  2,  6 }, /* index 252  */
{10,  1,  0,  341,  0,  2,  2,  6 }, /* index 253  */
{10,  1,  0, 1023,  0,  2,  2,  6 }, /* index 254  */
{10,  1,  0,  682,  0,  2,  2,  6 }  /* index 255  */
};
#endif

/* Defintion of delta value Table 6.1.2.1.1-5 spec 38.214 */
uint8_t puschDeltaTable[MAX_MU_PUSCH] = { 2, 3, 4, 6 };

uint16_t tbSizeTable[TOTAL_TBSIZE_VALUES] = {
         24,    32,    40,    48,    56,    64,    72,    80,    88,    96, \
        104,   112,   120,   128,   136,   144,   152,   160,   168,   176, \
        184,   192,   208,   224,   240,   256,   272,   288,   304,   320, \
        336,   352,   368,   384,   408,   432,   456,   480,   504,   528, \
        552,   576,   608,   640,   672,   704,   736,   768,   808,   848, \
        888,   928,   984,  1032,  1064,  1128,  1160,  1192,  1224,  1256, \
       1288,  1320,  1352,  1416,  1480,  1544,  1608,  1672,  1736,  1800, \
       1864,  1928,  2024,  2088,  2152,  2216,  2280,  2408,  2472,  2536, \
       2600,  2664,  2728,  2792,  2856,  2976,  3104,  3240,  3368,  3496, \
       3624,  3752,  3824 };

uint16_t mcsTable[32][3] = {
      {   0,   2,   120},   /* mcs index  0 */ 
      {   1,   2,   157},   /* mcs index  1 */ 
      {   2,   2,   193},   /* mcs index  2 */ 
      {   3,   2,   251},   /* mcs index  3 */ 
      {   4,   2,   308},   /* mcs index  4 */ 
      {   5,   2,   379},   /* mcs index  5 */ 
      {   6,   2,   449},   /* mcs index  6 */ 
      {   7,   2,   526},   /* mcs index  7 */ 
      {   8,   2,   602},   /* mcs index  8 */ 
      {   9,   2,   679},   /* mcs index  9 */ 
      {  10,   4,   340},   /* mcs index 10 */ 
      {  11,   4,   378},   /* mcs index 11 */ 
      {  12,   4,   434},   /* mcs index 12 */ 
      {  13,   4,   490},   /* mcs index 13 */ 
      {  14,   4,   553},   /* mcs index 14 */ 
      {  15,   4,   616},   /* mcs index 15 */
      {  16,   4,   658},   /* mcs index 16 */
      {  17,   6,   438},   /* mcs index 17 */
      {  18,   6,   466},   /* mcs index 18 */
      {  19,   6,   517},   /* mcs index 19 */
      {  20,   6,   567},   /* mcs index 20 */
      {  21,   6,   616},   /* mcs index 21 */
      {  22,   6,   666},   /* mcs index 22 */
      {  23,   6,   719},   /* mcs index 23 */
      {  24,   6,   772},   /* mcs index 24 */
      {  25,   6,   822},   /* mcs index 25 */
      {  26,   6,   873},   /* mcs index 26 */
      {  27,   6,   910},   /* mcs index 27 */
      {  28,   6,   948},   /* mcs index 28 */
      {  29,   2,     0},   /* mcs index 29 */
      {  30,   4,     0},   /* mcs index 30 */
      {  31,   6,     0}};  /* mcs index 31 */

/* PUCCH resource sets before dedicated PUCCH resource configuration */
/* Table 9.2.1-1 spec 38.213      */ 
uint8_t pucchResourceSet[MAX_PUCCH_RES_SET_IDX][4] = {
{ 0,  12,  2,  0 }, /* index  0 */
{ 0,  12,  2,  0 }, /* index  1 */
{ 0,  12,  2,  3 }, /* index  2 */
{ 1,  10,  4,  0 }, /* index  3 */
{ 1,  10,  4,  0 }, /* index  4 */
{ 1,  10,  4,  2 }, /* index  5 */
{ 1,  10,  4,  4 }, /* index  6 */
{ 1,   4, 10,  0 }, /* index  7 */
{ 1,   4, 10,  0 }, /* index  8 */
{ 1,   4, 10,  2 }, /* index  9 */
{ 1,   4, 10,  4 }, /* index 10 */
{ 1,   0, 14,  0 }, /* index 11 */
{ 1,   0, 14,  0 }, /* index 12 */
{ 1,   0, 14,  2 }, /* index 13 */
{ 1,   0, 14,  4 }, /* index 14 */
{ 1,   0, 14,  0 }, /* index 15 */
};

/* QoS Configuration */
/* 5QI value and Table Index Mapping */
uint16_t fiveQiIdxTable[MAX_5QI_TABLE_IDX] = {1, 2, 3, 4, 65, 66, 67, 75, 71, 72, 73, 74, 76, 5, 6, 7, 8, 9, 69, 70, 79, 80, 82, 83, 84, 85, 86};

/* 3GPP TS 23.501 Table 5.7.4-1: Standardized 5QI to QoS characteristics mapping */
/* Resource type(0 = GBR, 1 = Non-GBR, 2 = delay critical GBR) ,  Default Priority Level */
uint16_t fiveQiTable[MAX_5QI_TABLE_IDX][2] = {
      {0,   20},
      {0,   40},
      {0,   30},
      {0,   50},
      {0,   7},
      {0,   20},
      {0,   15},
      {0,   0}, /* 5QI Value = 75 doesn't define default priority level */
      {0,   56},
      {0,   56},
      {0,   56},
      {0,   56},
      {0,   56},
      {1,   10},
      {1,   60},
      {1,   70},
      {1,   80},
      {1,   90},
      {1,   5},
      {1,   55},
      {1,   65},
      {1,   68},
      {2,   19},
      {2,   22},
      {2,   24},
      {2,   21},
      {2,   18}
};

/* Minimum Msg3 scheduling time should be calculated based on N1+N2+NTAmax+0.5
 * ms formula.
 * Refer spec 38.213 section 8.3.
 * Harcoding the minimum msg3 scheduling for now */
uint8_t minMsg3SchTime[MAX_NUM_MU] = {6, 6, 6, 6};

uint8_t defaultUlAckTbl[DEFAULT_UL_ACK_LIST_COUNT]= {1, 2, 3 , 4, 5, 6, 7, 8};

uint8_t schCmnDlRvTbl[4] = {0, 2, 3, 1};
/**
 * @brief Function to find first DMRS symbol in PDSCH
 *
 * @details
 *
 *     Function: findDmrsStartSymbol
 *
 *     This function finds first DMRS symbol using DMRS symbol 
 *     position bitmap.
 *
 *  @param[in]  DMRS symbol position bitmap
 *  @return     Success : First DRMS symbol
 *              Failure : MAX_SYMB_PER_SLOT 
 **/
uint8_t findDmrsStartSymbol(uint16_t dlDmrsSymbBitMap)
{
   uint8_t position = 0;
   uint16_t mask = 1;

   while(position < MAX_SYMB_PER_SLOT)
   {
      if(dlDmrsSymbBitMap & mask)
         break;  
      mask = mask << 1;
      position++;
   }
   return position;   
}

/**
 * @brief Function to add a node to a linked list
 *
 * @details
 *
 *     Function: addNodeToLList
 *
 *     This function adds a new node to the linked list
 *
 *  @param[in]  Pointer to the list
 *              Pointer to node to be added
 *              Pointer to current node
 *  @return     ROK
 *              RFAILED
 **/
uint8_t addNodeToLList(CmLListCp *llist, void *blockToAdd, CmLList *currNode)
{
   CmLList  *newNode;

   SCH_ALLOC(newNode, sizeof(CmLList));
   if(newNode)
   {
      newNode->node = (PTR)blockToAdd;
      
      if(currNode == NULLP)
         cmLListAdd2Tail(llist, newNode);
      else
      {
         llist->crnt = currNode;
         cmLListInsAfterCrnt(llist, newNode);
      }
      return ROK;
   } 
   return RFAILED;
}

/**
 * @brief Function to delete a node from linked list
 *
 * @details
 *
 *     Function: deleteNodeFromLList
 *
 *     This function deletes a node from the linked list
 *
 *  @param[in]  Pointer to the list
 *              Pointer to node to be deleted
 *  @return     Pointer to the deleted node
 **/
uint8_t deleteNodeFromLList(CmLListCp *llist, CmLList *node)
{
   node = cmLListDelFrm(llist, node);
   SCH_FREE(node, sizeof(CmLList));

   return ROK;
}

/**
 * @brief Checks if requested PRBs are free
 *
 * @details
 *
 *     Function: isPrbAvailable
 *
 *     This functions loops through all free PRB blocks and 
 *     checks if request PRB block is available for allocation
 *
 *  @param[in]  List of free PRB blocks
 *              First PRB requested
 *              Total number of PRB requested
 *
 *  @return     Returns Pointer to free block
 *              NULL
 **/
CmLList* isPrbAvailable(CmLListCp *freePrbBlockList, uint16_t startPrb, uint16_t numPrb)
{
   uint16_t      endPrb = 0;
   CmLList       *node = NULLP;
   FreePrbBlock  *freeBlock = NULLP;

   endPrb = startPrb + numPrb - 1; 

   /* Iterate through all blocks of free PRB to check if requested PRBs can be assigned */
   node = freePrbBlockList->first;
   while(node)
   {
      freeBlock = (FreePrbBlock *)node->node;

      /* Check if requested number of blocks can be allocated from the current block */
      if(freeBlock->numFreePrb < numPrb)
      {
         DU_LOG("\nINFO   --> SCH: In isPrbAvailable, numFreePrb:%d is less than reqPrb:%d", freeBlock->numFreePrb, numPrb);
         node = node->next;
         continue;
      }
      
      /* Check if requested PRBs belong within the range of current free block */
      if(((startPrb >= freeBlock->startPrb) && (startPrb <= freeBlock->endPrb)) && \
         ((endPrb >= freeBlock->startPrb) && (endPrb <= freeBlock->endPrb)))
      {
         return node;
      }

      /* If current block is unable to provide resources, check the next block */
      node = node->next;
   }
   return NULLP;
}

/**
 * @brief Function to update free PRB list
 *
 * @details
 *
 *     Function: removeAllocatedPrbFromFreePrbList
 *
 *     This function removes the allocated PRBs from the
 *     list of free PRBs
 *
 *  @param[in]  Pointer to the list
 *              Pointer to node from which PRB was allocated
 *              Start PRB allocated
 *              Number of PRBs allocated
 *  @return     void
 **/
void removeAllocatedPrbFromFreePrbList(CmLListCp *freePrbBlockList, CmLList *node, uint16_t startPrb, uint16_t numPrb)
{
   uint16_t      endPrb;
   FreePrbBlock  *newBlock = NULLP;
   FreePrbBlock  *freeBlock = (FreePrbBlock *)node->node;

   if(!node) 
      return;
   
   endPrb = startPrb + numPrb -1;

   /* If the whole block is allocated, remove it from linked list */
   if(freeBlock->numFreePrb == numPrb)
   {
      if(deleteNodeFromLList(freePrbBlockList, node) == ROK)
         SCH_FREE(freeBlock, sizeof(FreePrbBlock));
   }

   /* If PRB is allocated from start of free block, move the start of free block
    * after last alloctaed PRB */
   else if(freeBlock->startPrb == startPrb)
   {
      freeBlock->startPrb = endPrb+1;
      freeBlock->numFreePrb = freeBlock->endPrb - freeBlock->startPrb +1;
   }

   /* If PRB is allocated from end of free block, move the end of free block
    * before the first allocated PRB */
   else if(freeBlock->endPrb == endPrb)
   {
      freeBlock->endPrb = startPrb-1;
      freeBlock->numFreePrb = freeBlock->endPrb - freeBlock->startPrb +1;
   }

   /* If PRBs are allocated somewhere in between the free block, split it into 2
    * nodes. Fist node contains free PRBs after the allocated PRBs. Second node
    * contains free PRBs present before the allocated PRBs */
   else
   {
      /* Block 2 */
      SCH_ALLOC(newBlock, sizeof(FreePrbBlock));
      if(newBlock)
      {
         newBlock->startPrb = freeBlock->startPrb;
         newBlock->endPrb = startPrb-1;
         newBlock->numFreePrb = newBlock->endPrb - newBlock->startPrb +1;
         addNodeToLList(freePrbBlockList, newBlock, node);
      }

      /* Block 1 */
      freeBlock->startPrb = endPrb+1;
      freeBlock->numFreePrb = freeBlock->endPrb - freeBlock->startPrb +1;
   }
}

/**
 * @brief frequency domain allocation function. 
 *
 * @details
 *
 *     Function: schCalcTbSize
 *     
 *     This function finds the TBSize from table Table 5.1.3.2-1 spec 38.214
 *     
 *  @param[in]  payLoadSize - size of payload in bytes
 *  @return     TBsize from the Table in bytes
 **/
uint16_t schCalcTbSize(uint32_t payLoadSize)
{
   uint8_t tbsIndex = 0;
   uint16_t maxTbSize;

   maxTbSize = tbSizeTable[TOTAL_TBSIZE_VALUES -1]/8;
   if(payLoadSize >= maxTbSize)
      return maxTbSize;

   payLoadSize = payLoadSize*8;
   while(payLoadSize > tbSizeTable[tbsIndex])
   {
      tbsIndex++;
   }

   /* return the TBsize in bytes */
   return (tbSizeTable[tbsIndex]/8);
}

/**
 * @brief frequency domain allocation function. 
 *
 * @details
 *
 *     Function: schCalcNumPrb
 *     
 *     This function calculates the number of PRbs 
 *     
 *  @param[in]  tbSize in bytes
 *  @param[in]  mcs
 *  @param[in]  number of symbols
 *  @return   number PRBs
 **/
uint16_t schCalcNumPrb(uint16_t tbSize, uint16_t mcs, uint8_t numSymbols)
{
   uint16_t numPrb = 0;
   uint16_t nre = 0;
   uint16_t nreDash = 0;
   uint8_t  qm     = mcsTable[mcs][1];
   uint16_t rValue = mcsTable[mcs][2];
   uint8_t  numLayer = 1;       /* v value */
   uint8_t  numDmrsRePerPrb = 12;

   tbSize = tbSize * 8; //Calculate tbSize in bits

   /* formula used for calculation of rbSize, 38.214 section 5.1.3.2 *
    * Ninfo = S . Nre . R . Qm . v                                       *
    * Nre' = Nsc . NsymPdsch - NdmrsSymb - Noh                       *
    * Nre = min(156,Nre') . nPrb                                     */

   nre = ceil( (float)tbSize * 1024 / (qm * rValue * numLayer));

   nreDash = ceil( (12 * numSymbols) - numDmrsRePerPrb - 0);

   if (nreDash > 156)
      nreDash = 156;

   numPrb = ceil((float)nre / nreDash);   
   return numPrb;
}

/**
* @brief calculation of transport block size.
*
* @details
*
*     Function: schCalcTbSizeFromNPrb
*
*     This function calculates the transport block size
*
*  @param[in]  nPrb is num PRB
*  @param[in]  mcs
*  @param[in]  number of symbols
*  @return   tbSize
**/
uint16_t schCalcTbSizeFromNPrb(uint16_t numPrb, uint16_t mcs, uint8_t numSymbols)
{   
   uint8_t  qm     = mcsTable[mcs][1];
   uint16_t rValue = mcsTable[mcs][2];
   uint16_t tbsIndex = 0;
   uint32_t tbSize = 0;
   uint32_t nre = 0;
   uint32_t nreDash = 0;
   uint32_t nInfo = 0;
   uint32_t n = 0;
   uint32_t nInfoDash = 0;
   uint32_t c = 0;
   const uint8_t  numLayer = 1;
   const uint16_t numRbSc = 12;
   const uint16_t numDmrsRes = 12;
   const uint16_t sf = 1;
//   uint16_t numPrbOvrHead = 0;
   
  /* formula used for calculation of rbSize, 38.214 section 5.1.3.2  *
   * Ninfo = Nre . R . Qm . v   where [ NInfo is tbSize]             *
   * Nre' = Nsc . NsymPdsch - NdmrsSymb - Noh                        *
   * Nre = min(156,Nre') . nPrb                                      */

   nreDash = MIN(156, ceil( (numRbSc * numSymbols) - numDmrsRes - 0));
   nre = nreDash * numPrb;
   nInfo = ceil(nre * qm * numLayer * rValue/(1024.0 * sf));

   if(nInfo <= 3824)
   {
      n = MAX(3, (uint32_t)cmLog2(nInfo) - 6);
      nInfoDash = MAX(24, (1<<n)*(nInfo/(1<<n)));
      while(nInfoDash > tbSizeTable[tbsIndex])
      {
         tbsIndex++;
      }
      tbSize = tbSizeTable[tbsIndex];
   }
   else
   {
      n = (uint32_t)cmLog2(nInfo - 24) - 5;
      nInfoDash = MAX(3840, (1<<n)*ceil((nInfo - 24)/(1<<n)));

      if(rValue<256)
      {
         c = ceil((nInfoDash + 24)/3816);
         tbSize = 8 * c * ceil((nInfoDash + 24)/(8 * c)) - 24;
      }
      else
      {
         if(nInfoDash > 8424)
         {
            c = ceil((nInfoDash + 24)/8424);
            tbSize = 8 * c * ceil((nInfoDash + 24)/(8 * c)) - 24;
         }
         else
         {
            tbSize = 8 * ceil((nInfoDash + 24)/(8)) - 24;
         }
      }
   }
   return tbSize;
}

/**
 * @brief fetching ueCb from cellCb
 *
 * @details
 *
 *     Function: schGetUeCb
 *
 *     This function fetched UeCb based on crnti from cellCb
 *
 *  @param[in]  cellCb
 *  @param[in]  crnti
 *  @return     ueCb
 **/
SchUeCb* schGetUeCb(SchCellCb *cellCb, uint16_t crnti)
{
   uint16_t ueId;
   GET_UE_ID(crnti, ueId);
   return &(cellCb->ueCb[ueId -1]);
}

/**
 * @brief initialize UL slot info
 *
 * @details
 *
 *     Function: schInitUlSlot
 *
 *     This function intializes UL slot of the cell
 *
 *  @param[in]  schUlSlotInfo
 *  @return     void
 **/
void schInitUlSlot(SchUlSlotInfo *schUlSlotInfo)
{
   CmLList *node = NULLP, *next = NULLP;
   FreePrbBlock *freeBlock;

   /* Delete the old blocks */
   if(schUlSlotInfo->prbAlloc.freePrbBlockList.count)
   {
      node = schUlSlotInfo->prbAlloc.freePrbBlockList.first;
   }
   while(node)
   {
      next = node->next;
      freeBlock = (FreePrbBlock *)node->node;
      if(deleteNodeFromLList(&schUlSlotInfo->prbAlloc.freePrbBlockList, node) == ROK)
         SCH_FREE(freeBlock, sizeof(FreePrbBlock));
      node = next;
   }

   /* Initilize UL Slot info and mark all PRBs as free */
   memset(schUlSlotInfo, 0, sizeof(SchUlSlotInfo));
   cmLListInit(&schUlSlotInfo->prbAlloc.freePrbBlockList);
   SCH_ALLOC(freeBlock, sizeof(FreePrbBlock));
   if(freeBlock)
   {
      freeBlock->numFreePrb = MAX_NUM_RB;
      freeBlock->startPrb = 0;
      freeBlock->endPrb = MAX_NUM_RB-1;
      addNodeToLList(&schUlSlotInfo->prbAlloc.freePrbBlockList, freeBlock, NULL);
   }

   schUlSlotInfo->puschCurrentPrb = PUSCH_START_RB;
   schUlSlotInfo->schPuschInfo = NULLP;
}

/**
 * @brief initialize DL slot info
 *
 * @details
 *
 *     Function: schInitDlSlot
 *
 *     This function intializes DL slot of the cell
 *
 *  @param[in]  schDlSlotInfo
 *  @return     void
 **/
void schInitDlSlot(SchDlSlotInfo *schDlSlotInfo)
{
   CmLList *node = NULLP, *next = NULLP;
   FreePrbBlock *freeBlock;

   /* Delete the old blocks */
   if(schDlSlotInfo->prbAlloc.freePrbBlockList.count)
      node = schDlSlotInfo->prbAlloc.freePrbBlockList.first;
   while(node)
   {
      next = node->next;
      freeBlock = (FreePrbBlock *)node->node;
      if(deleteNodeFromLList(&schDlSlotInfo->prbAlloc.freePrbBlockList, node) == ROK)
         SCH_FREE(freeBlock, sizeof(FreePrbBlock));
      node = next;
   }

   /* Initilize DL Slot info and mark all PRBs as free */
   memset(schDlSlotInfo, 0, sizeof(SchDlSlotInfo));
   cmLListInit(&schDlSlotInfo->prbAlloc.freePrbBlockList);
   SCH_ALLOC(freeBlock, sizeof(FreePrbBlock));
   if(freeBlock)
   {
      freeBlock->numFreePrb = MAX_NUM_RB;
      freeBlock->startPrb = 0;
      freeBlock->endPrb = MAX_NUM_RB-1;
      addNodeToLList(&schDlSlotInfo->prbAlloc.freePrbBlockList, freeBlock, NULL);
   }
}

/**
 * @brief Fill resource bit map
 *
 * @details
 *
 *     Function: fillPrbBitmap
 *
 *     This function updates bitMap to mark the allocated PRBs
 *
 *  @param[in]  schDlSlotInfo
 *  @return     void
 **/
bool fillPrbBitmap(uint64_t *prbBitMap, uint16_t startPrb, uint16_t numPrb)
{
   uint16_t bitMapIdx = 0;
   uint16_t offsetInFirstIdx = 0;
   uint32_t numBitsToSetInFirstIdx = 0;
   uint64_t mask = MASK_BIT64_ON;
   uint64_t bitmapBackup[PRB_BITMAP_MAX_IDX];

   /* Store backup of the bitmap in order to roll back if PRB allocation fails */
   memcpy(bitmapBackup, prbBitMap, sizeof(bitmapBackup));

   /* Calculate the bitmap idx and offset of bit in that idx, to start
    * allocating PRBs from */
   bitMapIdx = startPrb / PRB_BITMAP_IDX_LEN;
   offsetInFirstIdx = startPrb % PRB_BITMAP_IDX_LEN;

   /* If number of PRBs allocated >= number of unset bits in first idx starting from offset bit
    * then set all bits in first idx starting from offset bit
    * else set bits equal to number of PRBs allocated
    */
   numBitsToSetInFirstIdx = \
      (numPrb >= (PRB_BITMAP_IDX_LEN-offsetInFirstIdx)) ? (PRB_BITMAP_IDX_LEN-offsetInFirstIdx) : numPrb;

   mask = mask >> (PRB_BITMAP_IDX_LEN-numBitsToSetInFirstIdx);
   mask = mask<<offsetInFirstIdx;

   /* If PRBs to be allocated are not already in use, mark these PRBs as allocated */
   if(!(prbBitMap[bitMapIdx] & mask))
   {
      prbBitMap[bitMapIdx] = prbBitMap[bitMapIdx] | mask;

      bitMapIdx++;
      numPrb = numPrb - numBitsToSetInFirstIdx;
      /* Set all bits in a bitMapIdx until remaining numPrb is less than PRB_BITMAP_IDX_LEN */
      while(numPrb > PRB_BITMAP_IDX_LEN)
      {
         if(prbBitMap[bitMapIdx])
         {
            memcpy(prbBitMap, bitmapBackup, sizeof(bitmapBackup));
            return RFAILED;
         }
         prbBitMap[bitMapIdx] = MASK_BIT64_ON;
         bitMapIdx++;
         numPrb = numPrb - PRB_BITMAP_IDX_LEN;
      }

      /* Set bits for the remaining PRBs */
      if(numPrb)
      {
         mask = MASK_BIT64_ON;
         mask = mask >> (PRB_BITMAP_IDX_LEN-numPrb);
         if(!(prbBitMap[bitMapIdx] & mask))
         {
            prbBitMap[bitMapIdx] = prbBitMap[bitMapIdx] | mask;
         }
         else
         {
            memcpy(prbBitMap, bitmapBackup, sizeof(bitmapBackup));
            return RFAILED;
         }
      }
   }
   else
   {
      return RFAILED;
   }
   
   return ROK;
}


/**************************************************************************
 *
 * @brief Update the LCID Node in LCLL as per ActionType
 *
 * @details
 *
 *    Function : handleLcLList
 *
 *    Functionality:
 *     Search LCID in LCLL or if not found, create,Delete, or return
 *     node for this LCID
 *
 * @params[in] I/P > lcLinkList pointer (LcInfo list)
 *             I/P > lcId
 *             I/P > ActionType (Create,Delete or Just search) 
 *
 * @return lcNode > Pointer to the Node for that LcInfo
 *         If NULLP, FATAL FAILURE
 *
 * ***********************************************************************/
LcInfo* handleLcLList(CmLListCp *lcLL, uint8_t lcId, ActionTypeLL action)
{
   CmLList  *node = NULLP;
   LcInfo *lcNode = NULLP;
   bool found = FALSE;

   if(lcLL == NULLP)
   {
      DU_LOG("\nERROR  -->  SCH: LcList doesnt exist");
      return NULLP;
   }
   node = lcLL->first;

   /*Traversing the LC LinkList*/
   while(node)
   {
      lcNode = (LcInfo *)node->node;
      if(lcNode->lcId == lcId)
      { 
         found = TRUE;
         break;
      }
      node = node->next;
   }//end of while

   switch(action)
   {
      case SEARCH:
         {
            if(!found)
            {
               lcNode = NULLP;
            }
            return lcNode;
         }

      case CREATE:
         {
            if(node != NULLP)
               return lcNode;

            /*Need to add a new node for this LC*/

            /*List is empty; Initialize the LL ControlPointer*/
            if(lcLL->count == 0)
            {
               cmLListInit(lcLL);
            }

            lcNode = NULLP;
            /*Allocate the List*/
            SCH_ALLOC(lcNode, sizeof(LcInfo));
            if(lcNode)
            {
               lcNode->lcId = lcId;
               lcNode->reqBO = 0;
               lcNode->allocBO = 0;
               lcNode->allocPRB = 0;
            }
            else
            {
               DU_LOG("\nERROR  -->  SCH : Allocation of List failed,lcId:%d",lcId);
               return NULLP;
            }

            if(addNodeToLList(lcLL, lcNode, NULLP) == RFAILED)
            {
               DU_LOG("\nERROR  -->  SCH : failed to Add Node,lcId:%d",lcId);
               SCH_FREE(lcNode, sizeof(LcInfo));
               return NULLP;
            }
            return lcNode;
         }

      case DELETE:
         {
            if(!found ||  lcNode == NULLP)
            {
               DU_LOG("\nERROR  -->  SCH: LCID%d not found; thus Deletion unsuccessful",lcId);
            }
            else
            {
               if(deleteNodeFromLList(lcLL, node) == ROK)
                  SCH_FREE(lcNode, sizeof(LcInfo));

               DU_LOG("\nDEBUG  -->  SCH: LCID%d Deleted successfully",lcId);
            }
            return NULLP; 
         }
      case PRINT:
      case TRAVERSE_ALL:
        {
           break;
        }
      default:
         {
            DU_LOG("\nERROR  -->  SCH: Action type wrong: %d",action);
            break;
         }
   }
   return lcNode;
}

/**************************************************************************
 *
 * @brief Update ReqPRB for a partiular LCID in LC Linklist 
 *
 * @details
 *
 *    Function : updateLcListReqPRB
 *
 *    Functionality:
 *     Update ReqPRB for a partiular LCID in LC Linklist 
 *
 * @params[in] I/P > lcLinkList pointer (LcInfo list)
 *             I/P > lcId
 *             I/P > reqPRB
 *             I/P > payloadSize
 *
 * @return ROK/RFAILED
 *
 * ***********************************************************************/
uint8_t updateLcListReqPRB(CmLListCp *lcLL, uint8_t lcId, uint32_t payloadSize)
{
   LcInfo    *lcNode = NULLP;
   lcNode = handleLcLList(lcLL, lcId, CREATE);

   if(lcNode == NULLP)
   {
      DU_LOG("\nERROR  -->  SCH : LC is neither present nor able to create in List lcId:%d",lcId);
      return RFAILED;
   }

   lcNode->reqBO = payloadSize;
   lcNode->allocBO = 0;
   lcNode->allocPRB = 0; /*Re-Initializing the AllocPRB*/
   return ROK;
}

/**************************************************************************
 *
 * @brief Delete entire LC Linklist 
 *
 * @details
 *
 *    Function : deleteLcLL
 *
 *    Functionality:
 *      Delete entire LC Linklist 
 *
 * @params[in] lcLinkList pointer (LcInfo list)
 *
 * @return void
 *
 * ***********************************************************************/
void deleteLcLL(CmLListCp *lcLL)
{
   CmLList *node = NULLP, *next = NULLP;
   LcInfo *lcNode = NULLP;

   if(lcLL == NULLP)
   {
      DU_LOG("\nERROR  -->  SCH: LcList doesnt exist");
      return;
   }
   node = lcLL->first;

   while(node)
   {
      next = node->next;
      lcNode = (LcInfo *)node->node;
      if(deleteNodeFromLList(lcLL, node) == ROK)
         SCH_FREE(lcNode, sizeof(LcInfo));
      node = next;
   }
}

/****************************************************************************
 *
 * @brief Calculate the Estimated TBS Size based on Spec 38.421 , Sec 5.3.1.2
 *
 * @details
 *
 *    Function : calculateEstimateTBSize
 *
 *    Functionality:
 *       TBS Size calculation requires numPRB. Since exactPRB for reqBO is unknown thus 
 *       will give the PRB value(from 0 to maxRB) one by one and 
 *       try to find the TBS size closest to reqBO
 *
 * @params[in] I/P > reqBO, mcsIdx, num PDSCH symbols, 
 *             I/P > maxRB: Maximum PRB count to reach for calculating the TBS
 *             O/P > estPrb : Suitable PRB count for reaching the correct TBS
 *       
 *
 * @return TBS Size > Size which will can be allocated for this LC
 *        
 *
 *************************************************************************/
uint32_t calculateEstimateTBSize(uint32_t reqBO, uint16_t mcsIdx, uint8_t numSymbols,\
                                   uint16_t maxPRB, uint16_t *estPrb)
{
   uint32_t tbs = 0, effecBO = 0;

   *estPrb = MIN_PRB;
   /*Loop Exit: Either estPRB reaches the maxRB or TBS is found greater than equal to reqBO*/
   do
   {
      tbs = schCalcTbSizeFromNPrb(*estPrb, mcsIdx, numSymbols);

      /*TBS size calculated in above function is in Bits. 
       * So to convert it into Bytes , we right shift by 3. 
       * Eg: tbs=128 bits(1000 0000) ; Right Shift by 3: Tbs = 0001 0000(16 bytes)*/
      tbs = tbs >> 3;
      *estPrb += 1;
   }while((tbs < reqBO) && (*estPrb < maxPRB));

   /*Effective BO is the Grant which can be provided for this LC.
    * Here,it is decided based on whether we can fully cater its requirment (reqBO) 
    * or has to provide lesser grant due to resource limitation.
    * Thus effective BO/Grant for this LC will be min of TBS calculated and reqBO*/
   effecBO = MIN(tbs,reqBO);
   return (effecBO);
}


/*******************************************************************
*
* @brief deleting Page Info node from PageInfo List
*
* @details
*
*    Function : schDeleteFromPageInfoList
*
*    Functionality: deleting page Info node from Page Info List
*
* @params[in] CmLListCp *list, CmLList *node 
*
* @return void 
*
* ****************************************************************/
void schDeleteFromPageInfoList(CmLListCp *list, CmLList *node)
{
   SchPageInfo *pageInfo;

   if(node != NULLP)
   {
      pageInfo = (SchPageInfo *)node->node;
      if(deleteNodeFromLList(list, node) == ROK)
         SCH_FREE(pageInfo, sizeof(SchPageInfo));
   }
}

/*******************************************************************
*
* @brief searching for Page at a particular SFN 
*
* @details
*
*    Function : schPageInfoSearchFromPageList
*
*    Functionality: searching for Page at a particular SFN 
*
* @params[in] SlotTimingInfo slotInfo, CmLListCp *storedPageList
*
* @return pointer to SchPageInfo
*
* ****************************************************************/
CmLList *schPageInfoSearchFromPageList(SlotTimingInfo slotInfo, CmLListCp *storedPageList)
{
   CmLList         *node = NULLP;
   SchPageInfo     *pageInfo = NULLP;

   if(storedPageList->count)
   {
      CM_LLIST_FIRST_NODE(storedPageList, node);
      while(node)
      {
         pageInfo = (SchPageInfo*)node->node;
         if(pageInfo == NULLP)
         {
            DU_LOG("\nERROR  --> SCH: PageInfo empty");
         }
         else if(pageInfo->pageTxTime.sfn == slotInfo.sfn && 
               (pageInfo->pageTxTime.slot == slotInfo.slot))
         {
            return node;
         }
         node = node->next;
      }
   }
   return NULLP;
}

/*Below function for printing will be used in future so disabling it for now*/
#if 0
/****************************************************************************
 *
 * @brief Print the LC in list for debugging purpose 
 *
 * @details
 *
 *    Function : printLcLL
 *
 *    Functionality:
 *            For debugging purpose, for printing the LC in the order and
 *            parameters
 *
 * @params[in] LcList pointer 
 *       
 * @return void 
 *        
 *************************************************************************/
void printLcLL(CmLListCp *lcLL)
{
   CmLList *node = NULLP;
   LcInfo *lcNode = NULLP;

   if(lcLL == NULLP)
   {
      DU_LOG("\nINFO   -->  SCH: LcList doesnt exist");
      return;
   }
   node = lcLL->first;
   while(node)
   {
      lcNode = (LcInfo *)node->node;
      if(lcNode)
      {
         DU_LOG("\nINFO   -->  SCH : LcID:%d, [reqBO, allocBO, allocPRB]:[%d,%d,%d]",\
               lcNode->lcId,lcNode->reqBO, lcNode->allocBO, lcNode->allocPRB);
      }

      node = node->next;
   }
}
#endif

#ifdef NR_TDD

/**
 * @brief determines slot/symbol format
 *
 * @details
 *
 *     Function : schGetSlotSymbFrmt 
 *      
 *      This API is invoked to determine if current slot is DL or UL
 *           
 *  @param[in]  uint16_t slot
 *  @param[in]  uint32_t bitMap from cellCb
 *  @return  SlotConfig
 *      -# DL    - 0 
 *      -# UL    - 1
 *      -# FLEXI - 2
 **/
SlotConfig schGetSlotSymbFrmt(uint16_t slot, uint32_t bitMap)
{
   uint32_t offset = (slot)*2;
   return (bitMap & 0x3<<offset)>>offset;
#if 0
   SlotConfig slotFrmt;
   int mask1 = 0, mask2 = 0;

   slot = (slot%n)*2;//n num of slots in defined periodicity or num of symbols
   mask1 = 1<<(slot);
   mask2 = 1<<(slot+1);
   slotFrmt = ((mask1 & bitMap)>>slot) + (2*((mask2 & bitMap)>>(slot+1)));

   //printf("\n\n\n\n*****FormatType:%d Slot:%d****\n\n\n\n", slotFrmt, slot/2);

   return slotFrmt;
#endif
}

/**
 * @brief Determine total length of configured slot pattern for specific 
 *    periodicity for TDD
 *
 * @details
 *
 *     Function : calculateSlotPatternLength 
 *      
 *      Determine total length of configured slot pattern for specific periodicity based
 *      on slot duration for TDD
 *           
 *  @param[in]  uint8_t scs, uint8_t periodicity 
 *
 *  @return uint8_t slotPatternLength 
 **/

uint8_t calculateSlotPatternLength(uint8_t scs, uint8_t periodicity)
{
   uint8_t slotPatternLength =0;
   float   slotDuration = 0;
   
   /* Calculating the slot duration with the help of SCS.
    * This will provides the slot duration in ms like 1, 0.5, 0.25, 0.125. 
    * If scs value is SCS_30KHZ its enum value is 1, 
    * slotDuration = pow(0.5, 1);
    * slotDuration = 0.5 */

   slotDuration = pow(0.5,scs);

   /* Calculating length of pattern based on Transmission Periodicity. 
    * If periodicity = TX_PRDCTY_MS_5,
    * slotPatternLength = 5/0.5 
    * slotPatternLength = 10 i.e. {length of slot pattern DDDDDDDFUU}*/

   switch(periodicity)
   {
      case TX_PRDCTY_MS_0P5:
         slotPatternLength = 0.5/slotDuration;
         break;
      case TX_PRDCTY_MS_0P625:
         slotPatternLength = 0.625/slotDuration;
         break;
      case TX_PRDCTY_MS_1:
         slotPatternLength = 1/slotDuration;
         break;
      case TX_PRDCTY_MS_1P25:
         slotPatternLength = 1.25/slotDuration;
         break;
      case TX_PRDCTY_MS_2:
         slotPatternLength = 2/slotDuration;
         break;
      case TX_PRDCTY_MS_2P5:
         slotPatternLength = 2.5/slotDuration;
         break;
      case TX_PRDCTY_MS_5:
         slotPatternLength = 5/slotDuration;
         break;
      case TX_PRDCTY_MS_10:
         slotPatternLength = 10/slotDuration;
         break;
   }
   return slotPatternLength;
}
#endif

/*
 * As per FAPI spec, 
 * Frequency domain resources is a bitmap defining non-overlapping groups of 6 PRBs in ascending order.
 * [TS38.213 10.1]. Bitmap of uint8 array. 45 bits.
 *
 * As per IAPI,
 * CORESET-freqdom.frequencyDomainResources : The bits of the bitmap have a one-to-one mapping with
 * non-overlapping groups of 6 RBs. The most significant bit of the first word corresponds to
 * the most significant bit defined in 38.331.
 *
 * FAPI and IAPI both are 45 bits. Mapped from bit 0 LS Byte for the FAPI and
 * bit 0 LS U32 entry for IAPI.
 * FAPI is to be filled in following format such that Intel L1 is able to decode it :
 *
 *            FAPI                                 IAPI 
 * FreqDomainResource[0] bits 7-0     ->    nFreqDomain[0] bits 7-0
 * FreqDomainResource[1] bits 7-0     ->    nFreqDomain[0] bits 15-8
 * FreqDomainResource[2] bits 7-0     ->    nFreqDomain[0] bits 23-16
 * FreqDomainResource[3] bits 7-0     ->    nFreqDomain[0] bits 31-24
 * FreqDomainResource[4] bits 7-0     ->    nFreqDomain[1] bits 7-0
 * FreqDomainResource[5] bits 7-0     ->    nFreqDomain[1] bits 15-8
 *
 * where for the last entry bits 7,6 and 5 are don't care in the FAPI and bits
 * 31-13 are don't care in the IAPI.
 */
void covertFreqDomRsrcMapToIAPIFormat(uint8_t *sourceBitMap, uint8_t *destBitMap)
{
   int8_t  idx;
   uint8_t  numBitsToShift = 0;
   uint64_t freqDomainResources = 0;

   /* Bit operation to create a 64-bit integer that has
    * 48 LSBs [Bit 47 to Bit 0] mapped to sourceBitMap[0] to sourceBitMap[5]
    */
   for(idx = FREQ_DOM_RSRC_SIZE-1; idx >=0; idx--)
   {
      freqDomainResources |= ((uint64_t)sourceBitMap[idx] << numBitsToShift);
      numBitsToShift += 8;
   }

   /* Right shift 3 bits because bits[2-0] are unused in sourceBitMap[5] */
   freqDomainResources = freqDomainResources >> 3;

   /* Filling destBitMap such that LSB bit 0 of freqDomainResources maps to LSB 
    * of first word of destBitMap */
   numBitsToShift = 0;
   for(idx=0; idx<FREQ_DOM_RSRC_SIZE; idx++)
   {
      destBitMap[idx] = freqDomainResources >> numBitsToShift;
      numBitsToShift += 8;
   }
}
/**********************************************************************
         End of file
**********************************************************************/
